---
title: 子数组和问题
tags:
 - Array
categories:
 - algorithms
date: 2023-01-15
---

## [209. 长度最小的子数组 (Medium)](https://leetcode.cn/problems/minimum-size-subarray-sum/)

给定一个含有 n 个正整数的数组和一个正整数 target 。

找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [nums~l~, nums~l+1~, ..., nums~r-1~, nums~r~] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。

**示例 1：**

输入：target = 7, nums = [2,3,1,2,4,3]

输出：2

解释：子数组 [4,3] 是该条件下的长度最小的子数组。

**示例 2：**

输入：target = 4, nums = [1,4,4]

输出：1

**示例 3：**

输入：target = 11, nums = [1,1,1,1,1,1,1,1]

输出：0

**提示：**
- 1 <= target <= 10^9^
- 1 <= nums.length <= 10^5^
- 1 <= nums[i] <= 10^5^
 
**思路 A：**

滑动窗口

窗口左右端点位置分别为 left 和 i，变量 sum_sum 存储窗口里的数值之和。如果 sum_sum >= s，则从左端缩小窗口，同时计算窗口长度的最小值；如果 sum_num < s，则从右端点扩大窗口。

**代码 A：**

```cpp
class Solution(object):
    def minSubArrayLen(self, s, nums):
        """
        :type s: int
        :type nums: List[int]
        :rtype: int
        """
        left = 0
        sum_num = 0
        ans = float("inf")

        for i in range(len(nums)):
            sum_num += nums[i]
            while sum_num >= s:
                ans = min(ans, i - left + 1)
                sum_num -= nums[left]
                left += 1
        
        return ans if ans != float("inf") else 0
```

**思路 B:**

单调队列

前缀和数组 pre_sum，某个子数组的和，即为前缀和数组两个值之间的差值。所以遍历数组 nums 的每个数，当遍历到数值 nums[i] 时，要求出以 nums[i] 结尾的子数组和，即要找到 nums[i] 之前的前缀和的最小值即可。

所以求滑动窗口的最小值，使用单调队列即可，单调队列里面的值单调递增。

**代码 B:**

```cpp
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        n = len(nums)
        cnt = float('inf')
        pre_sum = [0] * (n + 1)
        for i in range(n):
            pre_sum[i + 1] = pre_sum[i] + nums[i]
        
        q = deque([0])
        for i in range(1, n + 1):
            while len(q) > 0 and pre_sum[i] - pre_sum[q[0]] >= target:
                cnt = min(cnt, i - q[0])
                q.popleft()
            
            while len(q) > 0 and pre_sum[q[-1]] >= pre_sum[i]:
                q.pop()
            q.append(i)

        return 0 if cnt == float('inf') else cnt
```

## [862. 和至少为 K 的最短子数组 (Hard)](https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/)

给你一个整数数组 nums 和一个整数 k ，找出 nums 中和至少为 k 的 最短非空子数组 ，并返回该子数组的长度。如果不存在这样的 子数组 ，返回 -1 。

子数组 是数组中 连续 的一部分。

**示例 1：**

输入：nums = [1], k = 1

输出：1

**示例 2：**

输入：nums = [1,2], k = 4

输出：-1

**示例 3：**

输入：nums = [2,-1,2], k = 3

输出：3

**提示：**
- 1 <= nums.length <= 10^5^
- -10^5^ <= nums[i] <= 10^5^
- 1 <= k <= 10^9^

**思路：**

单调队列

思路和 [209 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/) 一样，使用单调队列即可，但是不能使用滑动窗口解决这个问题，因为这个数组 nums 有负数存在。

**代码：**

```cpp
class Solution:
    def shortestSubarray(self, nums: List[int], k: int) -> int:
        n = len(nums)
        cnt = float('inf')
        pre_sum = [0] * (n + 1)
        for i in range(n):
            pre_sum[i + 1] = pre_sum[i] + nums[i]
        
        q = deque([0])
        for i in range(1, n + 1):
            while len(q) > 0 and pre_sum[i] - pre_sum[q[0]] >= k:
                cnt = min(cnt, i - q[0])
                q.popleft()
            
            while len(q) > 0 and pre_sum[q[-1]] >= pre_sum[i]:
                q.pop()
            q.append(i)

        return -1 if cnt == float('inf') else cnt
```
